[{"title":"docker use","url":"/2023/03/01/docker-use/","content":"<h1 id=\"DOCKER学习\"><a href=\"#DOCKER学习\" class=\"headerlink\" title=\"DOCKER学习\"></a>DOCKER学习</h1><p>对应大纲：<img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301085455109.png\" alt=\"image-20230301085455109\" style=\"zoom:25%;\" /></p>\n<h3 id=\"1、初识DOCKER\"><a href=\"#1、初识DOCKER\" class=\"headerlink\" title=\"1、初识DOCKER\"></a>1、初识DOCKER</h3><h5 id=\"Docker安装\"><a href=\"#Docker安装\" class=\"headerlink\" title=\"Docker安装\"></a>Docker安装</h5><p>三个环境：开发环境、测试环境、生产环境</p>\n<img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301085726456.png\" alt=\"image-20230301085726456\" style=\"zoom: 25%;\" />\n\n<p>环境不同可能会造成问题，手动迁移很麻烦。</p>\n<p>可以使用容器来迁移环境，解决软件跨环境迁移问题。</p>\n<p>Docker概念：Docker是一个开源的应用容器引擎，容器完全是使用沙箱机制，之间相互隔离，容器性能开销低。分为CE版和EE版</p>\n<p>安装docker，本次学习docker安装在centos7上</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1、yum 包更新到最新 </span></span><br><span class=\"line\">yum update</span><br><span class=\"line\"><span class=\"comment\"># 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 </span></span><br><span class=\"line\">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class=\"line\"><span class=\"comment\"># 3、 设置yum源</span></span><br><span class=\"line\">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class=\"line\"><span class=\"comment\"># 4、 安装docker，出现输入的界面都按 y </span></span><br><span class=\"line\">yum install -y docker-ce</span><br><span class=\"line\"><span class=\"comment\"># 5、 查看docker版本，验证是否验证成功</span></span><br><span class=\"line\">docker -v</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301092147712.png\" alt=\"image-20230301092147712\"  />\n\n<h5 id=\"Docker架构\"><a href=\"#Docker架构\" class=\"headerlink\" title=\"Docker架构\"></a>Docker架构</h5><p>图片示例：<img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301092338599.png\" alt=\"image-20230301092338599\" style=\"zoom: 33%;\" /></p>\n<p>对应概念：</p>\n<ul>\n<li><p>镜像（Image）：Docker 镜像（Image），就相当于是 一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包 含了完整的一套 Ubuntu16.04 最小系统的 root 文件系 统。 </p>\n</li>\n<li><p>容器（Container）：镜像（Image）和容器（Contain er）的关系，就像是面向对象程序设计中的类和对象一 样，镜像是静态的定义，容器是镜像运行时的实体。容 器可以被创建、启动、停止、删除、暂停等。</p>\n</li>\n</ul>\n<p>仓库（Repository）：仓库可看成一个代码控制中心， 用来保存镜像</p>\n<h5 id=\"配置Docker镜像加速器\"><a href=\"#配置Docker镜像加速器\" class=\"headerlink\" title=\"配置Docker镜像加速器\"></a>配置Docker镜像加速器</h5><p>使用阿里云镜像加速器</p>\n<p>修改daemon配置文件&#x2F;etc&#x2F;docker&#x2F;daemon.json来使用加速器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">mkdir</span> -p /etc/docker</span><br><span class=\"line\">sudo <span class=\"built_in\">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class=\"string\">&#x27;EOF&#x27;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;registry-mirrors&quot;</span>: [<span class=\"string\">&quot;https://5zu0nxqo.mirror.aliyuncs.com&quot;</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\">sudo systemctl daemon-reload</span><br><span class=\"line\">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301093225304.png\" alt=\"image-20230301093225304\"></p>\n<p>完成</p>\n<h3 id=\"2、Docker命令\"><a href=\"#2、Docker命令\" class=\"headerlink\" title=\"2、Docker命令\"></a>2、Docker命令</h3><h5 id=\"Docker服务相关命令\"><a href=\"#Docker服务相关命令\" class=\"headerlink\" title=\"Docker服务相关命令\"></a>Docker服务相关命令</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">启动docker服务:systemctl start docker </span><br><span class=\"line\">停止docker服务:systemctl stop docker </span><br><span class=\"line\">重启docker服务:systemctl restart docker</span><br><span class=\"line\">查看docker服务状态:systemctl status docker </span><br><span class=\"line\">设置开机启动docker服务:systemctl enable docker</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Docker镜像相关命令\"><a href=\"#Docker镜像相关命令\" class=\"headerlink\" title=\"Docker镜像相关命令\"></a>Docker镜像相关命令</h5><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">查看镜像: 查看本地所有的镜像</span><br><span class=\"line\">docker images</span><br><span class=\"line\">docker images –q <span class=\"comment\"># 查看所用镜像的id</span></span><br><span class=\"line\"></span><br><span class=\"line\">搜索镜像:从网络中查找需要的镜像</span><br><span class=\"line\">docker search 镜像名称</span><br><span class=\"line\"></span><br><span class=\"line\">拉取镜像:从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。</span><br><span class=\"line\">如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。</span><br><span class=\"line\">docker pull 镜像名称 eg:docker pull redis:3.2</span><br><span class=\"line\"></span><br><span class=\"line\">删除镜像: 删除本地镜像</span><br><span class=\"line\">docker rmi 镜像<span class=\"built_in\">id</span> <span class=\"comment\"># 删除指定本地镜像</span></span><br><span class=\"line\">docker rmi `docker images -q` <span class=\"comment\"># 删除所有本地镜像</span></span><br></pre></td></tr></table></figure>\n\n<p>想要看镜像有哪些版本可以去dockerhub：<a href=\"https://hub.docker.com/\">https://hub.docker.com/</a></p>\n<h5 id=\"Docker容器相关命令\"><a href=\"#Docker容器相关命令\" class=\"headerlink\" title=\"Docker容器相关命令\"></a>Docker容器相关命令</h5><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">查看容器</span><br><span class=\"line\">docker ps <span class=\"comment\"># 查看正在运行的容器</span></span><br><span class=\"line\">docker ps –a <span class=\"comment\"># 查看所有容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">创建容器</span><br><span class=\"line\">docker run 参数(可以使用docker run --<span class=\"built_in\">help</span>看对应说明)</span><br><span class=\"line\">-i：保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。</span><br><span class=\"line\">• -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。</span><br><span class=\"line\">• -d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker <span class=\"built_in\">exec</span> 进入容器。退出后，容器不会关闭。</span><br><span class=\"line\">• -it 创建的容器一般称为交互式容器，-<span class=\"built_in\">id</span> 创建的容器一般称为守护式容器</span><br><span class=\"line\">• --name：为创建的容器命名</span><br><span class=\"line\">docker run -it --name=cl centos:7 /bin/bash</span><br><span class=\"line\">docker run -<span class=\"built_in\">id</span> --name=c2 centos:7 </span><br><span class=\"line\"></span><br><span class=\"line\">进入容器</span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> 参数 <span class=\"comment\"># 退出容器，容器不会关闭</span></span><br><span class=\"line\"></span><br><span class=\"line\">启动容器</span><br><span class=\"line\">docker start 容器名称</span><br><span class=\"line\"></span><br><span class=\"line\">停止容器</span><br><span class=\"line\">docker stop 容器名</span><br><span class=\"line\"></span><br><span class=\"line\">删除容器</span><br><span class=\"line\">docker <span class=\"built_in\">rm</span> 容器名称</span><br><span class=\"line\"></span><br><span class=\"line\">查看容器信息</span><br><span class=\"line\">docker inspect 容器名称</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、Docker容器的数据卷\"><a href=\"#3、Docker容器的数据卷\" class=\"headerlink\" title=\"3、Docker容器的数据卷\"></a>3、Docker容器的数据卷</h3><h5 id=\"数据卷概念及作用\"><a href=\"#数据卷概念及作用\" class=\"headerlink\" title=\"数据卷概念及作用\"></a>数据卷概念及作用</h5><p>问题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Docker 容器删除后，在容器中产生的数据也会随之销毁 </span><br><span class=\"line\">Docker 容器和外部机器可以直接交换文件吗？ </span><br><span class=\"line\">容器之间想要进行数据交互？</span><br></pre></td></tr></table></figure>\n\n<p>数据卷：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">数据卷是宿主机中的一个目录或文件</span><br><span class=\"line\">当容器目录和数据卷目录绑定后，对方的修改会立即同步</span><br><span class=\"line\">一个数据卷可以被多个容器同时挂载</span><br><span class=\"line\">一个容器也可以被挂载多个数据卷</span><br></pre></td></tr></table></figure>\n\n<p>数据卷作用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">容器数据持久化 </span><br><span class=\"line\">外部机器和容器间接通信 </span><br><span class=\"line\">容器之间数据交换</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"配置数据卷\"><a href=\"#配置数据卷\" class=\"headerlink\" title=\"配置数据卷\"></a>配置数据卷</h5><p>创建启动容器时，使用 –v 参数 设置数据卷 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run ... –v 宿主机目录(文件):容器内目录(文件) ...  </span><br><span class=\"line\">注意事项： 1. 目录必须是绝对路径 2. 如果目录不存在，会自动创建 3. 可以挂载多个数据卷</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301101912652.png\" alt=\"image-20230301101912652\"></p>\n<p>可以看到能够同步，可以简单理解为共享文件夹</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301103733215.png\" alt=\"image-20230301103733215\"></p>\n<p><strong>如果忘了对应的数据卷可以用inspect看</strong></p>\n<h5 id=\"数据卷容器\"><a href=\"#数据卷容器\" class=\"headerlink\" title=\"数据卷容器\"></a>数据卷容器</h5><p>多容器进行数据交换 1. 多个容器挂载同一个数据卷 2. 数据卷容器</p>\n<img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301102705638.png\" alt=\"image-20230301102705638\" style=\"zoom: 67%;\" />\n\n<h5 id=\"配置数据卷容器\"><a href=\"#配置数据卷容器\" class=\"headerlink\" title=\"配置数据卷容器\"></a>配置数据卷容器</h5><p>1、创建启动c3数据卷容器，使用 –v 参数 设置数据卷 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run –it --name=c3 –v /volume centos:7 /bin/bash  </span><br></pre></td></tr></table></figure>\n\n<p>2、创建启动 c1 c2 容器，使用 –-volumes-from 参数 设置数据卷</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run –it --name=c1 --volumes-from c3 centos:7 /bin/bash </span><br><span class=\"line\">docker run –it --name=c2 --volumes-from c3 centos:7 /bin/bash </span><br></pre></td></tr></table></figure>\n\n","tags":["docker"]},{"title":"docker use","url":"/2023/03/01/docker/","content":"<h1 id=\"Docker学习\"><a href=\"#Docker学习\" class=\"headerlink\" title=\"Docker学习\"></a>Docker学习</h1><p>对应大纲：<img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301085455109.png\" alt=\"image-20230301085455109\" style=\"zoom:25%;\" /></p>\n<h3 id=\"1、初识DOCKER\"><a href=\"#1、初识DOCKER\" class=\"headerlink\" title=\"1、初识DOCKER\"></a>1、初识DOCKER</h3><h5 id=\"Docker安装\"><a href=\"#Docker安装\" class=\"headerlink\" title=\"Docker安装\"></a>Docker安装</h5><p>三个环境：开发环境、测试环境、生产环境</p>\n<img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301085726456.png\" alt=\"image-20230301085726456\" style=\"zoom: 25%;\" />\n\n<p>环境不同可能会造成问题，手动迁移很麻烦。</p>\n<p>可以使用容器来迁移环境，解决软件跨环境迁移问题。</p>\n<p>Docker概念：Docker是一个开源的应用容器引擎，容器完全是使用沙箱机制，之间相互隔离，容器性能开销低。分为CE版和EE版</p>\n<p>安装docker，本次学习docker安装在centos7上</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1、yum 包更新到最新 </span></span><br><span class=\"line\">yum update</span><br><span class=\"line\"><span class=\"comment\"># 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 </span></span><br><span class=\"line\">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class=\"line\"><span class=\"comment\"># 3、 设置yum源</span></span><br><span class=\"line\">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class=\"line\"><span class=\"comment\"># 4、 安装docker，出现输入的界面都按 y </span></span><br><span class=\"line\">yum install -y docker-ce</span><br><span class=\"line\"><span class=\"comment\"># 5、 查看docker版本，验证是否验证成功</span></span><br><span class=\"line\">docker -v</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301092147712.png\" alt=\"image-20230301092147712\"  />\n\n<h5 id=\"Docker架构\"><a href=\"#Docker架构\" class=\"headerlink\" title=\"Docker架构\"></a>Docker架构</h5><p>图片示例：<img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301092338599.png\" alt=\"image-20230301092338599\" style=\"zoom: 33%;\" /></p>\n<p>对应概念：</p>\n<ul>\n<li><p>镜像（Image）：Docker 镜像（Image），就相当于是 一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包 含了完整的一套 Ubuntu16.04 最小系统的 root 文件系 统。 </p>\n</li>\n<li><p>容器（Container）：镜像（Image）和容器（Contain er）的关系，就像是面向对象程序设计中的类和对象一 样，镜像是静态的定义，容器是镜像运行时的实体。容 器可以被创建、启动、停止、删除、暂停等。</p>\n</li>\n</ul>\n<p>仓库（Repository）：仓库可看成一个代码控制中心， 用来保存镜像</p>\n<h5 id=\"配置Docker镜像加速器\"><a href=\"#配置Docker镜像加速器\" class=\"headerlink\" title=\"配置Docker镜像加速器\"></a>配置Docker镜像加速器</h5><p>使用阿里云镜像加速器</p>\n<p>修改daemon配置文件&#x2F;etc&#x2F;docker&#x2F;daemon.json来使用加速器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">mkdir</span> -p /etc/docker</span><br><span class=\"line\">sudo <span class=\"built_in\">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class=\"string\">&#x27;EOF&#x27;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;registry-mirrors&quot;</span>: [<span class=\"string\">&quot;https://5zu0nxqo.mirror.aliyuncs.com&quot;</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\">sudo systemctl daemon-reload</span><br><span class=\"line\">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301093225304.png\" alt=\"image-20230301093225304\"></p>\n<p>完成</p>\n<h3 id=\"2、Docker命令\"><a href=\"#2、Docker命令\" class=\"headerlink\" title=\"2、Docker命令\"></a>2、Docker命令</h3><h5 id=\"Docker服务相关命令\"><a href=\"#Docker服务相关命令\" class=\"headerlink\" title=\"Docker服务相关命令\"></a>Docker服务相关命令</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">启动docker服务:systemctl start docker </span><br><span class=\"line\">停止docker服务:systemctl stop docker </span><br><span class=\"line\">重启docker服务:systemctl restart docker</span><br><span class=\"line\">查看docker服务状态:systemctl status docker </span><br><span class=\"line\">设置开机启动docker服务:systemctl enable docker</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Docker镜像相关命令\"><a href=\"#Docker镜像相关命令\" class=\"headerlink\" title=\"Docker镜像相关命令\"></a>Docker镜像相关命令</h5><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">查看镜像: 查看本地所有的镜像</span><br><span class=\"line\">docker images</span><br><span class=\"line\">docker images –q <span class=\"comment\"># 查看所用镜像的id</span></span><br><span class=\"line\"></span><br><span class=\"line\">搜索镜像:从网络中查找需要的镜像</span><br><span class=\"line\">docker search 镜像名称</span><br><span class=\"line\"></span><br><span class=\"line\">拉取镜像:从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。</span><br><span class=\"line\">如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。</span><br><span class=\"line\">docker pull 镜像名称 eg:docker pull redis:3.2</span><br><span class=\"line\"></span><br><span class=\"line\">删除镜像: 删除本地镜像</span><br><span class=\"line\">docker rmi 镜像<span class=\"built_in\">id</span> <span class=\"comment\"># 删除指定本地镜像</span></span><br><span class=\"line\">docker rmi `docker images -q` <span class=\"comment\"># 删除所有本地镜像</span></span><br></pre></td></tr></table></figure>\n\n<p>想要看镜像有哪些版本可以去dockerhub：<a href=\"https://hub.docker.com/\">https://hub.docker.com/</a></p>\n<h5 id=\"Docker容器相关命令\"><a href=\"#Docker容器相关命令\" class=\"headerlink\" title=\"Docker容器相关命令\"></a>Docker容器相关命令</h5><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">查看容器</span><br><span class=\"line\">docker ps <span class=\"comment\"># 查看正在运行的容器</span></span><br><span class=\"line\">docker ps –a <span class=\"comment\"># 查看所有容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">创建容器</span><br><span class=\"line\">docker run 参数(可以使用docker run --<span class=\"built_in\">help</span>看对应说明)</span><br><span class=\"line\">-i：保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。</span><br><span class=\"line\">• -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。</span><br><span class=\"line\">• -d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker <span class=\"built_in\">exec</span> 进入容器。退出后，容器不会关闭。</span><br><span class=\"line\">• -it 创建的容器一般称为交互式容器，-<span class=\"built_in\">id</span> 创建的容器一般称为守护式容器</span><br><span class=\"line\">• --name：为创建的容器命名</span><br><span class=\"line\">docker run -it --name=cl centos:7 /bin/bash</span><br><span class=\"line\">docker run -<span class=\"built_in\">id</span> --name=c2 centos:7 </span><br><span class=\"line\"></span><br><span class=\"line\">进入容器</span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> 参数 <span class=\"comment\"># 退出容器，容器不会关闭</span></span><br><span class=\"line\"></span><br><span class=\"line\">启动容器</span><br><span class=\"line\">docker start 容器名称</span><br><span class=\"line\"></span><br><span class=\"line\">停止容器</span><br><span class=\"line\">docker stop 容器名</span><br><span class=\"line\"></span><br><span class=\"line\">删除容器</span><br><span class=\"line\">docker <span class=\"built_in\">rm</span> 容器名称</span><br><span class=\"line\"></span><br><span class=\"line\">查看容器信息</span><br><span class=\"line\">docker inspect 容器名称</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、Docker容器的数据卷\"><a href=\"#3、Docker容器的数据卷\" class=\"headerlink\" title=\"3、Docker容器的数据卷\"></a>3、Docker容器的数据卷</h3><h5 id=\"数据卷概念及作用\"><a href=\"#数据卷概念及作用\" class=\"headerlink\" title=\"数据卷概念及作用\"></a>数据卷概念及作用</h5><p>问题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Docker 容器删除后，在容器中产生的数据也会随之销毁 </span><br><span class=\"line\">Docker 容器和外部机器可以直接交换文件吗？ </span><br><span class=\"line\">容器之间想要进行数据交互？</span><br></pre></td></tr></table></figure>\n\n<p>数据卷：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">数据卷是宿主机中的一个目录或文件</span><br><span class=\"line\">当容器目录和数据卷目录绑定后，对方的修改会立即同步</span><br><span class=\"line\">一个数据卷可以被多个容器同时挂载</span><br><span class=\"line\">一个容器也可以被挂载多个数据卷</span><br></pre></td></tr></table></figure>\n\n<p>数据卷作用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">容器数据持久化 </span><br><span class=\"line\">外部机器和容器间接通信 </span><br><span class=\"line\">容器之间数据交换</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"配置数据卷\"><a href=\"#配置数据卷\" class=\"headerlink\" title=\"配置数据卷\"></a>配置数据卷</h5><p>创建启动容器时，使用 –v 参数 设置数据卷 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run ... –v 宿主机目录(文件):容器内目录(文件) ...  </span><br><span class=\"line\">注意事项： 1. 目录必须是绝对路径 2. 如果目录不存在，会自动创建 3. 可以挂载多个数据卷</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301101912652.png\" alt=\"image-20230301101912652\"></p>\n<p>可以看到能够同步，可以简单理解为共享文件夹</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301103733215.png\" alt=\"image-20230301103733215\"></p>\n<p><strong>如果忘了对应的数据卷可以用inspect看</strong></p>\n<h5 id=\"数据卷容器\"><a href=\"#数据卷容器\" class=\"headerlink\" title=\"数据卷容器\"></a>数据卷容器</h5><p>多容器进行数据交换 1. 多个容器挂载同一个数据卷 2. 数据卷容器</p>\n<img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301102705638.png\" alt=\"image-20230301102705638\" style=\"zoom: 67%;\" />\n\n<h5 id=\"配置数据卷容器\"><a href=\"#配置数据卷容器\" class=\"headerlink\" title=\"配置数据卷容器\"></a>配置数据卷容器</h5><p>1、创建启动c3数据卷容器，使用 –v 参数 设置数据卷 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run –it --name=c3 –v /volume centos:7 /bin/bash  </span><br></pre></td></tr></table></figure>\n\n<p>2、创建启动 c1 c2 容器，使用 –-volumes-from 参数 设置数据卷</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run –it --name=c1 --volumes-from c3 centos:7 /bin/bash </span><br><span class=\"line\">docker run –it --name=c2 --volumes-from c3 centos:7 /bin/bash </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、Docker应用部署\"><a href=\"#4、Docker应用部署\" class=\"headerlink\" title=\"4、Docker应用部署\"></a>4、Docker应用部署</h3><h5 id=\"MySql部署：\"><a href=\"#MySql部署：\" class=\"headerlink\" title=\"MySql部署：\"></a>MySql部署：</h5><p>需求：在Docker容器中部署MySQL，并通过外部mysql客户端操作MySQL Server。</p>\n<p>案例：① 搜索mysql镜像 ② 拉取mysql镜像 ③ 创建容器 ④ 操作容器中的mysql</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">当容器中的网络服务需要被外部机器访问时，可以将容器中提供服务的端口映射到宿主机的端口上。外部机 器访问宿主机的该端口，从而间接访问容器的服务。 </span><br><span class=\"line\"></span><br><span class=\"line\">这种操作称为：端口映射</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301105421936.png\" alt=\"image-20230301105421936\"></p>\n<ol>\n<li>搜索mysql镜像</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker search mysql</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>拉取mysql镜像</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull mysql:5.6</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>创建容器，设置端口映射、目录映射</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">在/root目录下创建mysql目录用于存储mysql数据信息</span></span><br><span class=\"line\">mkdir ~/mysql</span><br><span class=\"line\">cd ~/mysql</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -id \\</span><br><span class=\"line\">-p 3307:3306 \\</span><br><span class=\"line\">--name=c_mysql \\</span><br><span class=\"line\">-v $PWD/conf:/etc/mysql/conf.d \\</span><br><span class=\"line\">-v $PWD/logs:/logs \\</span><br><span class=\"line\">-v $PWD/data:/var/lib/mysql \\</span><br><span class=\"line\">-e MYSQL_ROOT_PASSWORD=123456 \\</span><br><span class=\"line\">mysql:5.6</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>参数说明：<ul>\n<li><strong>-p 3307:3306</strong>：将容器的 3306 端口映射到宿主机的 3307 端口。</li>\n<li><strong>-v $PWD&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d</strong>：将主机当前目录下的 conf&#x2F;my.cnf 挂载到容器的 &#x2F;etc&#x2F;mysql&#x2F;my.cnf。配置目录</li>\n<li><strong>-v $PWD&#x2F;logs:&#x2F;logs</strong>：将主机当前目录下的 logs 目录挂载到容器的 &#x2F;logs。日志目录</li>\n<li><strong>-v $PWD&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql</strong> ：将主机当前目录下的data目录挂载到容器的 &#x2F;var&#x2F;lib&#x2F;mysql 。数据目录</li>\n<li><strong>-e MYSQL_ROOT_PASSWORD&#x3D;123456：</strong>初始化 root 用户的密码。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li>进入容器，操作mysql</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec –it c_mysql /bin/bash</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301115710533.png\" alt=\"image-20230301115710533\"></p>\n<ol start=\"5\">\n<li>使用外部机器连接容器中的mysql</li>\n</ol>\n<h5 id=\"部署Tomcat\"><a href=\"#部署Tomcat\" class=\"headerlink\" title=\"部署Tomcat\"></a>部署Tomcat</h5><p>要求：在Docker容器中部署Tomcat，并通过外部机器访问Tomcat部署的项目。</p>\n<p>实现步骤 ① 搜索tomcat镜像 ② 拉取tomcat镜像 ③ 创建容器 ④ 部署项目 ⑤ 测试访问</p>\n<ol>\n<li>搜索tomcat镜像</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker search tomcat</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>拉取tomcat镜像</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull tomcat</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>创建容器，设置端口映射、目录映射</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">在/root目录下创建tomcat目录用于存储tomcat数据信息</span></span><br><span class=\"line\">mkdir ~/tomcat</span><br><span class=\"line\">cd ~/tomcat</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -id --name=c_tomcat \\</span><br><span class=\"line\">-p 8080:8080 \\</span><br><span class=\"line\">-v $PWD:/usr/local/tomcat/webapps \\</span><br><span class=\"line\">tomcat </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>参数说明：</p>\n<ul>\n<li><p><strong>-p 8080:8080：</strong>将容器的8080端口映射到主机的8080端口</p>\n<p><strong>-v $PWD:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps：</strong>将主机中当前目录挂载到容器的webapps</p>\n</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li><p>使用外部机器访问tomcat</p>\n<img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301141233554.png\" alt=\"image-20230301141233554\" style=\"zoom:50%;\" />\n\n<p>成功</p>\n</li>\n</ol>\n<h5 id=\"部署Nginx\"><a href=\"#部署Nginx\" class=\"headerlink\" title=\"部署Nginx\"></a>部署Nginx</h5><p>需求：在Docker容器中部署Nginx，并通过外部机器访问Nginx</p>\n<p>步骤：① 搜索Nginx镜像 ② 拉取Nginx镜像 ③ 创建容器 ④ 测试访问</p>\n<ol>\n<li>搜索nginx镜像</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker search nginx</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>拉取nginx镜像</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull nginx</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>创建容器，设置端口映射、目录映射</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">在/root目录下创建nginx目录用于存储nginx数据信息</span></span><br><span class=\"line\">mkdir ~/nginx</span><br><span class=\"line\">cd ~/nginx</span><br><span class=\"line\">mkdir conf</span><br><span class=\"line\">cd conf</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容</span></span><br><span class=\"line\">vim nginx.conf</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">user  nginx;</span><br><span class=\"line\">worker_processes  1;</span><br><span class=\"line\"></span><br><span class=\"line\">error_log  /var/log/nginx/error.log warn;</span><br><span class=\"line\">pid        /var/run/nginx.pid;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    worker_connections  1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       /etc/nginx/mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\"></span><br><span class=\"line\">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class=\"line\">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class=\"line\">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">    access_log  /var/log/nginx/access.log  main;</span><br><span class=\"line\"></span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    #tcp_nopush     on;</span><br><span class=\"line\"></span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\"></span><br><span class=\"line\">    #gzip  on;</span><br><span class=\"line\"></span><br><span class=\"line\">    include /etc/nginx/conf.d/*.conf;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -id --name=c_nginx \\</span><br><span class=\"line\">-p 80:80 \\</span><br><span class=\"line\">-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \\</span><br><span class=\"line\">-v $PWD/logs:/var/log/nginx \\</span><br><span class=\"line\">-v $PWD/html:/usr/share/nginx/html \\</span><br><span class=\"line\">nginx</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>参数说明：<ul>\n<li><strong>-p 80:80</strong>：将容器的 80端口映射到宿主机的 80 端口。</li>\n<li><strong>-v $PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</strong>：将主机当前目录下的 &#x2F;conf&#x2F;nginx.conf 挂载到容器的 :&#x2F;etc&#x2F;nginx&#x2F;nginx.conf。配置目录</li>\n<li><strong>-v $PWD&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx</strong>：将主机当前目录下的 logs 目录挂载到容器的&#x2F;var&#x2F;log&#x2F;nginx。日志目录</li>\n</ul>\n</li>\n</ul>\n<ol start=\"4\">\n<li><p>使用外部机器访问nginx</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301142036233.png\" alt=\"image-20230301142036233\"></p>\n</li>\n</ol>\n<h5 id=\"部署Redis\"><a href=\"#部署Redis\" class=\"headerlink\" title=\"部署Redis\"></a>部署Redis</h5><p>需求：在Docker容器中部署Redis，并通过外部机器访问Redis。</p>\n<p>实现步骤 ① 搜索Redis镜像 ② 拉取Redis镜像 ③ 创建容器 ④ 测试访问</p>\n<ol>\n<li>搜索redis镜像</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker search redis</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>拉取redis镜像</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull redis:5.0</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>创建容器，设置端口映射</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -id --name=c_redis -p 6379:6379 redis:5.0</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>使用外部机器连接redis</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">./redis-cli.exe -h 192.168.149.135 -p 6379</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301142459588.png\" alt=\"image-20230301142459588\"></p>\n<h3 id=\"5、Dockerfile\"><a href=\"#5、Dockerfile\" class=\"headerlink\" title=\"5、Dockerfile\"></a>5、Dockerfile</h3><h5 id=\"Docker镜像原理\"><a href=\"#Docker镜像原理\" class=\"headerlink\" title=\"Docker镜像原理\"></a>Docker镜像原理</h5><p>问题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Docker 镜像本质是什么？</span><br><span class=\"line\">Docker 中一个centos镜像为什么只有200MB，而一个centos操作系统的iso文件要几个个G？</span><br><span class=\"line\">Docker 中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？</span><br></pre></td></tr></table></figure>\n\n<p>理论知识：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">操作系统组成部分：</span><br><span class=\"line\">进程通信子系统</span><br><span class=\"line\">内存管理子系统</span><br><span class=\"line\">备管理子系统</span><br><span class=\"line\">文件管理子系统</span><br><span class=\"line\">网络通信子系统</span><br><span class=\"line\">作业控制子系统</span><br><span class=\"line\">进程调度子系统</span><br><span class=\"line\"></span><br><span class=\"line\">Linux文件系统由bootfs和rootfs两部分组成</span><br><span class=\"line\">• bootfs：包含bootloader（引导加载程序）和 kernel（内核）</span><br><span class=\"line\">• rootfs： root文件系统，包含的就是典型 Linux 系统中的/dev，/proc，/bin，/etc等标准目录和文件</span><br><span class=\"line\">• 不同的linux发行版，bootfs基本一样，而rootfs不同，如ubuntu，centos等</span><br></pre></td></tr></table></figure>\n\n<img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301143313641.png\" alt=\"image-20230301143313641\" style=\"zoom:67%;\" />\n\n<p>问题回答：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. Docker 镜像本质是什么？</span><br><span class=\"line\">• 是一个分层文件系统</span><br><span class=\"line\">2. Docker 中一个centos镜像为什么只有200MB，而一个centos操作系统的iso文件要几个个G？</span><br><span class=\"line\">• Centos的iso镜像文件包含bootfs和rootfs，而docker的centos镜像复用操作系统的bootfs，只有rootfs和其他镜像层</span><br><span class=\"line\">3. Docker 中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？</span><br><span class=\"line\">• 由于docker中镜像是分层的，tomcat虽然只有70多MB，但他需要依赖于父镜像和基础镜像，所有整个对外暴露的tomcat镜像大小500多MB</span><br></pre></td></tr></table></figure>\n\n<p>docker inspect tomcat 效果：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301143908837.png\" alt=\"image-20230301143908837\"></p>\n<h5 id=\"Docker镜像制作\"><a href=\"#Docker镜像制作\" class=\"headerlink\" title=\"Docker镜像制作\"></a>Docker镜像制作</h5><img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301144055969.png\" alt=\"image-20230301144055969\" style=\"zoom:50%;\" />\n\n<p> 注意：</p>\n<ol>\n<li>自己制作镜像时，目录挂载不会生效，其它会保存</li>\n</ol>\n<h5 id=\"Dockerfile概念\"><a href=\"#Dockerfile概念\" class=\"headerlink\" title=\"Dockerfile概念\"></a>Dockerfile概念</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Dockerfile 是一个文本文件 </span><br><span class=\"line\">包含了一条条的指令 </span><br><span class=\"line\">每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像 </span><br><span class=\"line\">对于开发人员：可以为开发团队提供一个完全一致的开发环境 </span><br><span class=\"line\">对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件 构建一个新的镜像开始工作了 </span><br><span class=\"line\">对于运维人员：在部署时，可以实现应用的无缝移</span><br></pre></td></tr></table></figure>\n\n<p>参考网站：<a href=\"https://hub.docker.com/\">https://hub.docker.com</a></p>\n<h5 id=\"Dockerfile关键字\"><a href=\"#Dockerfile关键字\" class=\"headerlink\" title=\"Dockerfile关键字\"></a>Dockerfile关键字</h5><table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>作用</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>FROM</td>\n<td>指定父镜像</td>\n<td>指定dockerfile基于那个image构建</td>\n</tr>\n<tr>\n<td>MAINTAINER</td>\n<td>作者信息</td>\n<td>用来标明这个dockerfile谁写的</td>\n</tr>\n<tr>\n<td>LABEL</td>\n<td>标签</td>\n<td>用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看</td>\n</tr>\n<tr>\n<td>RUN</td>\n<td>执行命令</td>\n<td>执行一段命令 默认是&#x2F;bin&#x2F;sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”]</td>\n</tr>\n<tr>\n<td>CMD</td>\n<td>容器启动命令</td>\n<td>提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”]</td>\n</tr>\n<tr>\n<td>ENTRYPOINT</td>\n<td>入口</td>\n<td>一般在制作一些执行就关闭的容器中会使用</td>\n</tr>\n<tr>\n<td>COPY</td>\n<td>复制文件</td>\n<td>build的时候复制文件到image中</td>\n</tr>\n<tr>\n<td>ADD</td>\n<td>添加文件</td>\n<td>build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务</td>\n</tr>\n<tr>\n<td>ENV</td>\n<td>环境变量</td>\n<td>指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name&#x3D;value</td>\n</tr>\n<tr>\n<td>ARG</td>\n<td>构建参数</td>\n<td>构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数</td>\n</tr>\n<tr>\n<td>VOLUME</td>\n<td>定义外部可以挂载的数据卷</td>\n<td>指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”]</td>\n</tr>\n<tr>\n<td>EXPOSE</td>\n<td>暴露端口</td>\n<td>定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080&#x2F;udp</td>\n</tr>\n<tr>\n<td>WORKDIR</td>\n<td>工作目录</td>\n<td>指定容器内部的工作目录 如果没有创建则自动创建 如果指定&#x2F; 使用的是绝对地址 如果不是&#x2F;开头那么是在上一条workdir的路径的相对路径</td>\n</tr>\n<tr>\n<td>USER</td>\n<td>指定执行用户</td>\n<td>指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户</td>\n</tr>\n<tr>\n<td>HEALTHCHECK</td>\n<td>健康检查</td>\n<td>指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制</td>\n</tr>\n<tr>\n<td>ONBUILD</td>\n<td>触发器</td>\n<td>当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大</td>\n</tr>\n<tr>\n<td>STOPSIGNAL</td>\n<td>发送信号量到宿主机</td>\n<td>该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。</td>\n</tr>\n<tr>\n<td>SHELL</td>\n<td>指定执行脚本的shell</td>\n<td>指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell</td>\n</tr>\n</tbody></table>\n<h5 id=\"案例1\"><a href=\"#案例1\" class=\"headerlink\" title=\"案例1\"></a>案例1</h5><p>需求：定义dockerfile，发布springboot项目</p>\n<p>实现步骤 ① 定义父镜像：FROM java:8 ② 定义作者信息：MAINTAINER itheima  ③ 将jar包添加到容器： ADD springboot.jar app.jar ④ 定义容器启动执行的命令：CMD java–jar app.jar ⑤ 通过dockerfile构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本</p>\n<p>成功</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301152821606.png\" alt=\"image-20230301152821606\"></p>\n<h5 id=\"案例2\"><a href=\"#案例2\" class=\"headerlink\" title=\"案例2\"></a>案例2</h5><p>需求：自定义centos7镜像。</p>\n<p>要求：1.默认登录路经为&#x2F;usr 2.可以使用vim</p>\n<p>dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> centos:<span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> realikun404</span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> yum install -y vim</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /usr</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> /bin/bash</span></span><br></pre></td></tr></table></figure>\n\n<p>然后</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker build -f dockerfile -t mycentos:1 .</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、Docker服务编排\"><a href=\"#6、Docker服务编排\" class=\"headerlink\" title=\"6、Docker服务编排\"></a>6、Docker服务编排</h3><h5 id=\"服务编排概念\"><a href=\"#服务编排概念\" class=\"headerlink\" title=\"服务编排概念\"></a>服务编排概念</h5><p>微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停 ，维护的工作量会很大。 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">要从Dockerfile build image 或者去dockerhub拉取image </span><br><span class=\"line\">要创建多个container </span><br><span class=\"line\">要管理这些container（启动停止删除） </span><br></pre></td></tr></table></figure>\n\n<p>服务编排： 按照一定的业务规则批量管理容器</p>\n<h5 id=\"Docker-Compose概述\"><a href=\"#Docker-Compose概述\" class=\"headerlink\" title=\"Docker Compose概述\"></a>Docker Compose概述</h5><p>Docker Compose是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建 ，启动和停止。使用步骤：</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 利用 Dockerfile 定义运行环境镜像</li>\n<li><input disabled=\"\" type=\"checkbox\"> 使用 docker-compose.yml 定义组成应用的各服务</li>\n<li><input disabled=\"\" type=\"checkbox\"> 运行 docker-compose up 启动应用</li>\n</ul>\n<h5 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h5><p>安装Docker Compose</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我 们以编译好的二进制包方式安装在Linux系统中。</span> </span><br><span class=\"line\">curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">设置文件可执行权限</span> </span><br><span class=\"line\">chmod +x /usr/local/bin/docker-compose</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看版本信息</span> </span><br><span class=\"line\">docker-compose -version</span><br></pre></td></tr></table></figure>\n\n<p>卸载Docker Compose</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">二进制包方式安装的，删除二进制文件即可</span></span><br><span class=\"line\">rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>\n\n\n\n<p>使用docker compose编排nginx+springboot项目</p>\n<ol>\n<li>创建docker-compose目录</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir ~/docker-compose</span><br><span class=\"line\">cd ~/docker-compose</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编写 docker-compose.yml 文件</li>\n</ol>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"code\"><pre><span class=\"line\">version: <span class=\"string\">&#x27;3&#x27;</span></span><br><span class=\"line\">services:</span><br><span class=\"line\">  nginx:</span><br><span class=\"line\">   image: nginx</span><br><span class=\"line\">   ports:</span><br><span class=\"line\">    - <span class=\"number\">80</span>:<span class=\"number\">80</span></span><br><span class=\"line\">   links:</span><br><span class=\"line\">    - app</span><br><span class=\"line\">   volumes:</span><br><span class=\"line\">    - ./nginx/conf.d:/etc/nginx/conf.d</span><br><span class=\"line\">  app:</span><br><span class=\"line\">    image: app</span><br><span class=\"line\">    <span class=\"keyword\">expose</span>:</span><br><span class=\"line\">      - <span class=\"string\">&quot;8080&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>创建.&#x2F;nginx&#x2F;conf.d目录</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir -p ./nginx/conf.d</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"4\">\n<li>在.&#x2F;nginx&#x2F;conf.d目录下 编写itheima.conf文件</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    access_log off;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://app:8080;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>在~&#x2F;docker-compose 目录下 使用docker-compose 启动容器</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker-compose up</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>测试访问</li>\n</ol>\n<h3 id=\"7、私有镜像\"><a href=\"#7、私有镜像\" class=\"headerlink\" title=\"7、私有镜像\"></a>7、私有镜像</h3><p>略</p>\n<h3 id=\"8、Docker容器虚拟化与传统虚拟机相比\"><a href=\"#8、Docker容器虚拟化与传统虚拟机相比\" class=\"headerlink\" title=\"8、Docker容器虚拟化与传统虚拟机相比\"></a>8、Docker容器虚拟化与传统虚拟机相比</h3><p><img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301161119318.png\" alt=\"image-20230301161119318\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/image-20230301161129373.png\" alt=\"image-20230301161129373\"></p>\n","tags":["docker"]},{"title":"杀戮尖塔观者流派介绍","url":"/2023/02/15/%E6%9D%80%E6%88%AE%E5%B0%96%E5%A1%94%E8%A7%82%E8%80%85/","content":"<p><img src=\"https://cdn.jsdelivr.net/gh/realikun404/p1cg0_u4e/PicGo/20230215113853.png\"><br>眼前的场景是那样的普通，以至于巴顿没觉得有任何问题。</p>\n<p>虽然他隐约觉得有一点熟悉，但并不认为这值得奇怪：</p>\n<p>每天都会看到的场景怎么会没有一点熟悉感？</p>\n<p>他目光移动，望向了高空，只见绯红的月亮静静悬挂，挥洒着光芒，让人心情不由自主就沉淀了下来。</p>\n<p>这一刻，巴顿似乎卸下了无形的重担，身心都异常轻松，再也没有了之前的那种恐慌，焦虑和烦躁。</p>\n<p>他的灵性直觉告诉他，弗纳尔这件事情到此结束了，不会再影响到他的生活。</p>\n<p>“风暴在上，感谢主的庇佑。”巴顿旋即握右拳击左胸，小声自语了一句。</p>\n<p>没有了那种担忧和紧绷，他只觉疲惫如同洪水，奔腾着从自己灵魂深处涌了出来，淹没了大脑，淹没了四肢，淹没了身体的每一个细胞。</p>\n<p>巴顿忍不住用手背抵住嘴巴，打了个哈欠，但脸上却多了几分惬意的笑容。</p>\n<p>他没再停留于书房，转身离开这里，一路回到卧室，以享受般的状态泡了个澡，喝了一小杯红酒。</p>\n<p>这一晚，巴顿没再做梦，睡得异常踏实。</p>\n<p>当他早晨醒来时，精神舒展，愉悦暗涌，就仿佛获得了新的一次人生。</p>\n<p>看了眼旁边还在熟睡的妻子，巴顿小心起床，换好衣物，于家附近走了一圈。</p>\n<p>他之前从未发现自己所在的街区是如此的美好：</p>\n<p>空气清新，环境安宁，风景怡人，就连行人都是那样的有教养。</p>\n<p>这让巴顿的心情愈发得好，再次深刻地认识到弗纳尔的事情结束了，自己又回到普通宁和的生活中了。</p>\n<p>他保持着这样的心情，回到家中，和妻儿一起享用起早餐。</p>\n<p>这个过程中，他甚至给妻子讲了讲报纸上登载的笑话，满足了孩子们一个小小的要求。</p>\n<p>看到妻儿脸上的笑容，巴顿由衷地感到满足。</p>\n<p>然后，他穿上外套，戴好帽子，提着手杖，出门乘坐无轨公共马车，一路来到位于城区边缘的“鲁恩古物搜集和保护基金会”。</p>\n<p>进入自己的办公室，巴顿找回了往日的节奏，先不忙着工作，而是给自家准备起加了些奇特草药的红茶。</p>\n<p>就着红茶，悠闲地读完了家里没订阅的那几份报纸，他才拿起收到的信和文件，依次审阅。</p>\n<p>这样的流程，这样的节奏，让他感觉异常舒坦。</p>\n<p>唯一的一点不谐在于，巴顿还是有点担心又收到弗纳尔的信。</p>\n<p>不过，这种担忧没有变成现实。</p>\n<p>大概一刻钟后，他的办公室房门被人笃笃笃敲响。</p>\n<p>“请进。”巴顿端起杯子，喝了口红茶。</p>\n<p>推门而入的是“合规部”副主管，外貌普通，没有特色，但让人感觉亲切的帕切科.道恩。</p>\n<p>“昨晚睡得还好吗？”帕切科立于门口，打招呼般问道。</p>\n<p>“非常棒。”巴顿未做隐瞒。</p>\n<p>帕切科点了下头，微笑说道：</p>\n<p>“看来你确实已经摆脱了这件事情的影响。”</p>\n<p>巴顿没说自己做的那个“噩梦”，转而问道：</p>\n<p>“你呢？”</p>\n<p>“我也睡得很好。”帕切科笑着回应道，“警方已完全接手了这件事情，据说昨晚就找到弗纳尔了，可惜，他似乎遭遇了不幸。”</p>\n<p>“可怜的人，愿他能得到安宁。”巴顿没有说愿主庇佑他，因为弗纳尔已经背弃了对“风暴之主”的信仰，如果真有“庇佑”，那必然是闪电加风暴。</p>\n<p>说完，想到帕切科之前提供的帮助，以及对方令人亲切的姿态，巴顿主动说道：</p>\n<p>“等会一起享用午餐？”</p>\n<p>“你请客吗？”帕切科笑着说道。</p>\n<p>“当然，很高兴认识你这么一位朋友。”</p>\n","tags":["-test1 -test2"]}]